<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Концепт 2: Информативный</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <style>
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    details summary {
      list-style: none;
    }
    details summary::-webkit-details-marker {
      display: none;
    }
    details[open] summary svg:last-child {
      transform: rotate(180deg);
    }
    details {
      overflow: hidden;
    }
    
    details summary {
      user-select: none;
      cursor: pointer;
    }
    details summary svg:last-child {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Анимация для changelog-content - базовые стили */
    .changelog-content {
      overflow: hidden;
      padding-top: 0.5rem;
      margin-top: 0.5rem;
      will-change: max-height, opacity, transform;
    }
    
    /* Начальное состояние для GSAP (будет переопределено JS) */
    .changelog-content > * {
      will-change: transform, opacity;
    }
    .animate-fade-in { animation: fadeIn 0.3s ease-out; }
    .animate-slide-up { animation: slideUp 0.5s ease-out; }
  </style>
  <script>
    function initTheme() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      document.documentElement.classList.toggle('dark', savedTheme === 'dark');
      updateThemeButton(savedTheme);
    }

    function toggleTheme() {
      const isDark = document.documentElement.classList.toggle('dark');
      const theme = isDark ? 'dark' : 'light';
      localStorage.setItem('theme', theme);
      updateThemeButton(theme);
    }

    function updateThemeButton(theme) {
      const btn = document.getElementById('theme-toggle');
      if (btn) {
        btn.innerHTML = theme === 'dark' 
          ? '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>'
          : '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>';
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      initTheme();
      
      // Инициализация таймера после загрузки DOM
      initCountdown();
      
      // Улучшенная анимация для details элементов (с проверкой GSAP)
      // Ждем загрузки GSAP, если он еще не загружен
      if (typeof gsap !== 'undefined') {
        initDetailsAnimation();
      } else {
        // Если GSAP еще не загружен, ждем немного и пробуем снова
        setTimeout(() => {
          if (typeof gsap !== 'undefined') {
            initDetailsAnimation();
          } else {
            console.warn('GSAP не загружен, используется fallback анимация');
            initDetailsAnimationFallback();
          }
        }, 100);
      }
    });
    
    // Функция для GSAP анимации details
    function initDetailsAnimation() {
      if (typeof gsap === 'undefined') {
        console.warn('GSAP не загружен, используется fallback анимация');
        initDetailsAnimationFallback();
        return;
      }

      const detailsElements = document.querySelectorAll('details');
      
      detailsElements.forEach(detail => {
        const content = detail.querySelector('.changelog-content');
        if (!content) return;
        
        const cards = Array.from(content.children);
        let tl = null;
        let resizeTimeout = null;
        
        // Функция для расчета высоты контента
        const calculateHeight = () => {
          // Временно делаем контент видимым для измерения
          const wasVisible = content.style.visibility;
          const wasPointerEvents = content.style.pointerEvents;
          const wasPosition = content.style.position;
          const wasHeight = content.style.height;
          const wasMaxHeight = content.style.maxHeight;
          
          content.style.visibility = 'visible';
          content.style.pointerEvents = 'auto';
          content.style.position = 'static';
          content.style.height = 'auto';
          content.style.maxHeight = 'none';
          
          // Принудительный reflow
          void content.offsetHeight;
          
          const height = content.scrollHeight;
          
          // Восстанавливаем стили
          content.style.visibility = wasVisible;
          content.style.pointerEvents = wasPointerEvents;
          content.style.position = wasPosition;
          content.style.height = wasHeight;
          content.style.maxHeight = wasMaxHeight;
          
          return height;
        };
        
        // Создание timeline для открытия
        const createOpenTimeline = () => {
          const height = calculateHeight();
          
          // Устанавливаем начальное состояние
          gsap.set(content, {
            maxHeight: 0,
            opacity: 0,
            y: -10,
            overflow: 'hidden'
          });
          
          gsap.set(cards, {
            y: 20,
            opacity: 0
          });
          
          // Создаем timeline
          const timeline = gsap.timeline({ paused: true });
          
          // Анимация контейнера с явным указанием начального и конечного состояния
          timeline.fromTo(content, 
            {
              maxHeight: 0,
              opacity: 0,
              y: -10
            },
            {
              maxHeight: height,
              opacity: 1,
              y: 0,
              duration: 0.4,
              ease: 'power3.out',
              overflow: 'hidden'
            }
          );
          
          // Анимация карточек с задержкой
          timeline.fromTo(cards,
            {
              y: 20,
              opacity: 0
            },
            {
              y: 0,
              opacity: 1,
              duration: 0.4,
              ease: 'power3.out',
              stagger: 0.08
            }, '-=0.1');
          
          return timeline;
        };
        
        // Создание timeline для закрытия
        const createCloseTimeline = () => {
          const height = calculateHeight();
          
          // Элементы уже в открытом состоянии, не трогаем их
          
          // Создаем timeline
          const timeline = gsap.timeline({ paused: true });
          
          // Анимация контейнера - от открытого к закрытому
          timeline.to(content, {
            maxHeight: 0,
            opacity: 0,
            y: -10,
            duration: 0.4,
            ease: 'power3.out',
            overflow: 'hidden'
          });
          
          // Анимация карточек - обратный stagger
          timeline.to(cards, {
            y: 20,
            opacity: 0,
            duration: 0.4,
            ease: 'power3.out',
            stagger: -0.08 // Обратный порядок
          }, '-=0.1');
          
          return timeline;
        };
        
        // Инициализация начального состояния
        if (!detail.open) {
          gsap.set(content, {
            maxHeight: 0,
            opacity: 0,
            y: -10,
            overflow: 'hidden'
          });
          gsap.set(cards, {
            y: 20,
            opacity: 0
          });
        } else {
          const height = calculateHeight();
          gsap.set(content, {
            maxHeight: height,
            opacity: 1,
            y: 0,
            overflow: 'hidden'
          });
          gsap.set(cards, {
            y: 0,
            opacity: 1
          });
        }
        
        // Обработчик события toggle
        detail.addEventListener('toggle', function() {
          if (this.open) {
            // Открытие: создаем timeline для открытия и запускаем
            if (tl) {
              tl.kill();
            }
            tl = createOpenTimeline();
            tl.play(0);
          } else {
            // Закрытие: создаем timeline для закрытия и запускаем
            if (tl) {
              tl.kill();
            }
            
            // Создаем timeline для закрытия (элементы уже в открытом состоянии)
            tl = createCloseTimeline();
            tl.play(0);
          }
        });
        
        // Обработчик изменения размера окна
        const handleResize = () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            if (detail.open && tl) {
              const height = calculateHeight();
              gsap.set(content, { maxHeight: height });
              // Пересоздаем timeline для открытого состояния
              tl.kill();
              tl = createOpenTimeline();
              tl.progress(1);
            }
          }, 150);
        };
        
        window.addEventListener('resize', handleResize);
      });
    }
    
    // Fallback функция на случай, если GSAP не загрузился
    function initDetailsAnimationFallback() {
      const detailsElements = document.querySelectorAll('details');
      
      detailsElements.forEach(detail => {
        const content = detail.querySelector('.changelog-content');
        if (!content) return;
        
        if (!detail.open) {
          content.style.maxHeight = '0';
          content.style.opacity = '0';
          content.style.transform = 'translateY(-10px)';
        }
        
        detail.addEventListener('toggle', function() {
          if (this.open) {
            const height = content.scrollHeight;
            content.style.maxHeight = '0';
            content.style.opacity = '0';
            content.style.transform = 'translateY(-10px)';
            
            void content.offsetHeight;
            
            requestAnimationFrame(() => {
              content.style.maxHeight = height + 'px';
              content.style.opacity = '1';
              content.style.transform = 'translateY(0)';
            });
          } else {
            const currentHeight = content.scrollHeight;
            content.style.maxHeight = currentHeight + 'px';
            content.style.opacity = '1';
            content.style.transform = 'translateY(0)';
            
            void content.offsetHeight;
            
            requestAnimationFrame(() => {
              content.style.maxHeight = '0';
              content.style.opacity = '0';
              content.style.transform = 'translateY(-10px)';
            });
          }
        });
      });
    }

    // Счетчик обратного отсчета
    function initCountdown() {
      let countdown = 10;
      let isPaused = false;
      let countdownInterval = null;
      let hasReloaded = false; // Флаг, чтобы не перезагружать страницу несколько раз
      
      const countdownDisplay = document.getElementById('countdown-display');
      const countdownText = document.getElementById('countdown-text');
      const progressBar = document.getElementById('progress-bar');
      const modal = document.querySelector('.glass-effect');

      if (!countdownDisplay || !countdownText || !progressBar) {
        console.error('Элементы таймера не найдены!');
        return;
      }

      function getProgressColor(progress) {
        // progress от 0 до 100
        // От синего (0%) к красному (100%)
        if (progress < 50) {
          // От синего к желтому (0-50%)
          const ratio = progress / 50;
          const r = Math.round(59 + (255 - 59) * ratio); // 59 -> 255
          const g = Math.round(130 + (193 - 130) * ratio); // 130 -> 193
          const b = Math.round(246 + (7 - 246) * ratio); // 246 -> 7
          return `rgb(${r}, ${g}, ${b})`;
        } else {
          // От желтого к красному (50-100%)
          const ratio = (progress - 50) / 50;
          const r = Math.round(255 + (239 - 255) * ratio); // 255 -> 239
          const g = Math.round(193 + (68 - 193) * ratio); // 193 -> 68
          const b = Math.round(7 + (68 - 7) * ratio); // 7 -> 68
          return `rgb(${r}, ${g}, ${b})`;
        }
      }

      function updateCountdown() {
        if (isPaused) return;
        
        // Обновляем отображение
        countdownDisplay.textContent = countdown;
        countdownText.textContent = countdown;
        
        // Обновляем прогресс-бар (опустошается справа налево)
        const progress = ((10 - countdown) / 10) * 100;
        progressBar.style.width = `${100 - progress}%`;
        progressBar.style.marginLeft = 'auto'; // Выравнивание справа
        
        // Меняем цвет от синего к красному (инвертируем, т.к. прогресс идет наоборот)
        const color = getProgressColor(100 - progress);
        progressBar.style.background = color;
        
        if (countdown > 0) {
          countdown--;
        } else {
          // Таймер закончился - перезагружаем страницу ТОЛЬКО ОДИН РАЗ
          if (!hasReloaded) {
            hasReloaded = true;
            clearInterval(countdownInterval);
            // Не перезагружаем автоматически в демо-версии
            // if (window.safeReload) {
            //   window.safeReload(true);
            // } else {
            //   window.location.reload(true);
            // }
            console.log('Таймер завершен. В реальном приложении здесь будет перезагрузка.');
          }
        }
      }

      function startCountdown() {
        if (countdownInterval) {
          clearInterval(countdownInterval);
        }
        // Обновляем сразу при старте
        updateCountdown();
        // Затем каждую секунду
        countdownInterval = setInterval(updateCountdown, 1000);
      }

      function pauseCountdown() {
        isPaused = true;
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
      }

      function resumeCountdown() {
        if (isPaused) {
          isPaused = false;
          // Обновляем сразу при возобновлении
          updateCountdown();
          // Затем продолжаем интервал
          if (!countdownInterval) {
            countdownInterval = setInterval(updateCountdown, 1000);
          }
        }
      }

      // Обработчики для паузы при наведении
      if (modal) {
        modal.addEventListener('mouseenter', pauseCountdown);
        modal.addEventListener('mouseleave', resumeCountdown);
      }

      // Запускаем счетчик после небольшой задержки
      setTimeout(() => {
        startCountdown();
      }, 500);
    }
  </script>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen flex items-center justify-center p-4 transition-colors duration-300">
  <!-- Theme Toggle Button -->
  <button
    id="theme-toggle"
    onclick="toggleTheme()"
    class="fixed top-4 right-4 z-50 p-3 bg-white dark:bg-gray-800 rounded-full shadow-lg hover:shadow-xl transition-all duration-200 border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 hover:scale-110"
    title="Переключить тему"
  >
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
    </svg>
  </button>
  <!-- Overlay -->
  <div class="fixed inset-0 bg-black/40 dark:bg-black/60 backdrop-blur-sm animate-fade-in z-50 transition-colors duration-300"></div>
  
  <!-- Modal -->
  <div class="glass-effect rounded-xl p-5 shadow-2xl w-full mx-4 animate-slide-up relative z-50" style="max-width: 336px;">
    <!-- Header with Version and Countdown -->
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-500 dark:text-gray-400">v1.3.0</span>
        <span class="text-xs text-gray-500 dark:text-gray-400">→</span>
        <div class="px-2 py-0.5 bg-blue-500/20 dark:bg-blue-500/30 rounded-full border border-blue-500/30">
          <span class="text-xs font-semibold text-blue-600 dark:text-blue-400">v1.4.0</span>
        </div>
      </div>
      <div class="text-right">
        <div class="text-xl font-bold text-gray-900 dark:text-white" id="countdown-display">10</div>
        <div class="text-[10px] text-gray-500 dark:text-gray-400">сек</div>
      </div>
    </div>

    <!-- Title -->
    <div class="text-center mb-4">
      <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-1">
        Доступно обновление
      </h2>
      <p class="text-xs text-gray-600 dark:text-gray-400">
        Рекомендуем обновиться для новых возможностей
      </p>
    </div>

    <!-- Progress Bar -->
    <div class="mb-4">
      <div class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden shadow-inner flex">
        <div class="h-full rounded-full transition-all duration-1000 relative overflow-hidden ml-auto" id="progress-bar" style="width: 100%; background: rgb(59, 130, 246);">
          <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer"></div>
        </div>
      </div>
      <div class="text-center mt-1.5 text-[10px] text-gray-500 dark:text-gray-400">
        Автообновление через <span id="countdown-text">10</span> сек
      </div>
    </div>

    <!-- Changelog Categories (Collapsible) -->
    <details class="mb-4">
      <summary class="cursor-pointer text-sm font-semibold text-gray-900 dark:text-white mb-2 hover:text-blue-600 dark:hover:text-blue-400 transition-colors flex items-center gap-1.5">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
        </svg>
        Что нового? (5 изменений)
        <svg class="w-3 h-3 ml-auto transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
        </svg>
      </summary>
      
      <div class="changelog-content space-y-2">
        <!-- Новые возможности -->
        <div class="p-2.5 bg-green-50 dark:bg-green-900/20 rounded-lg border border-green-200 dark:border-green-800">
          <div class="flex items-center gap-1.5 mb-1.5">
            <svg class="w-4 h-4 text-green-600 dark:text-green-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
            </svg>
            <span class="text-xs font-semibold text-green-700 dark:text-green-400">Новые возможности</span>
          </div>
          <ul class="space-y-0.5 text-xs text-gray-700 dark:text-gray-300 ml-5.5">
            <li>• Экспорт данных в Excel формат</li>
            <li>• Новые темы оформления</li>
          </ul>
        </div>

        <!-- Улучшения -->
        <div class="p-2.5 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
          <div class="flex items-center gap-1.5 mb-1.5">
            <svg class="w-4 h-4 text-blue-600 dark:text-blue-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            <span class="text-xs font-semibold text-blue-700 dark:text-blue-400">Улучшения</span>
          </div>
          <ul class="space-y-0.5 text-xs text-gray-700 dark:text-gray-300 ml-5.5">
            <li>• Оптимизирована производительность дашборда</li>
            <li>• Улучшен интерфейс импорта данных</li>
          </ul>
        </div>

        <!-- Исправления -->
        <div class="p-2.5 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg border border-yellow-200 dark:border-yellow-800">
          <div class="flex items-center gap-1.5 mb-1.5">
            <svg class="w-4 h-4 text-yellow-600 dark:text-yellow-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span class="text-xs font-semibold text-yellow-700 dark:text-yellow-400">Исправления</span>
          </div>
          <ul class="space-y-0.5 text-xs text-gray-700 dark:text-gray-300 ml-5.5">
            <li>• Исправлены ошибки импорта JSON</li>
          </ul>
        </div>
      </div>
    </details>

    <!-- Buttons -->
    <div class="flex gap-2">
      <button class="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors shadow-lg hover:shadow-xl">
        Обновить сейчас
      </button>
      <button class="flex-1 px-3 py-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 text-sm font-medium rounded-lg transition-colors">
        Позже
      </button>
    </div>
  </div>

  <style>
    .glass-effect {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
    .dark .glass-effect {
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(75, 85, 99, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    .animate-shimmer {
      animation: shimmer 2s infinite;
    }
  </style>
</body>
</html>

